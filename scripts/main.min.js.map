{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","app/scripts/index.coffee","main.min.js","app/scripts/calculator.coffee","app/scripts/fractions-parser.coffee","app/scripts/fractions-peg-parser.js","app/scripts/fractions.coffee"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"$","jQuery","$buffer","$buttons","$calculator","$decimal","$output","$parsed","calculator","charCodes","getKey","output","toggleButtons","asciiMath","decimal","text","MathJax","Hub","Queue","Typeset","get","html","onError","alert","$b","data","map","this","charCodeAt","keypress","key","keyCode","which","String","fromCharCode","toUpperCase","index","input","keydown","uninput","preventDefault","click","each","canInput","removeAttribute","setAttribute","focus","./calculator",2,"module","Parser","options","$input","calc","clear","process","curr","isRes","val","v","hasResult","exp","parsed","parse","ast","error","incomplete","match","value","slice","trim","render","rendered","result","toFloat","toString","./fractions-parser",3,"Parsed","addMissingTerm","fraction","interpret","parser","tryParseAsIncompleteExpression","last","recur","arg","type","_error","closeParens","newExp","numParensAdded","openParens","termsAdded","message","interpreter","post","num","create","add","reduce","p","minus","mul","mixed","over","pairs","div","push","withResult","toMixedString","missing","op","replace","ast1","prototype","./fractions","./fractions-peg-parser",4,"peg$subclass","child","parent","ctor","constructor","SyntaxError","expected","found","offset","line","column","name","peg$computePosDetails","pos","advance","details","startPos","endPos","ch","charAt","seenCR","peg$cachedPos","peg$cachedPosDetails","peg$fail","peg$maxFailPos","peg$currPos","peg$maxFailExpected","peg$buildException","cleanupExpected","sort","b","description","splice","buildMessage","stringEscape","hex","expectedDesc","foundDesc","expectedDescs","Array","join","posDetails","peg$parseS","s0","peg$parseE","s1","s2","s3","s4","s5","peg$silentFails","peg$parseT","peg$FAILED","peg$c3","peg$c4","peg$c5","peg$c6","peg$c1","peg$reportedPos","peg$c7","peg$c0","peg$parseF","peg$c9","peg$c10","peg$c11","peg$c8","peg$parseR","peg$c13","peg$c14","peg$c15","peg$parseI","peg$c16","peg$c17","peg$parseU","peg$c18","peg$c12","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c19","peg$c27","test","peg$c28","peg$c29","peg$c26","peg$c31","peg$c30","terms","peg$result","arguments","peg$startRuleFunctions","S","peg$startRuleFunction","left","right","concat","whole","sign","expression","digits","parseInt","startRule",5,"Fraction","div0","gcd","d","Math","abs","ref","isProper","floor","w","c"],"mappings":"CAAA,QAAAA,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,GAAA,kBAAAC,UAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EAAA,IAAAK,GAAA,GAAAC,OAAA,uBAAAN,EAAA,IAAA,MAAAK,GAAAE,KAAA,mBAAAF,EAAA,GAAAG,GAAAX,EAAAG,IAAAS,WAAAb,GAAAI,GAAA,GAAAU,KAAAF,EAAAC,QAAA,SAAAd,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,EAAAA,EAAAF,IAAAa,EAAAA,EAAAC,QAAAd,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAS,QAAA,IAAA,GAAAL,GAAA,kBAAAD,UAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAa,OAAAX,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAa,GAAA,SAAAT,GCAA,GAAAU,IAAAA,EAEIC,QAEF,WACA,GAAAC,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,CCkEA,ODlEAR,GAAcJ,EAAE,eAChBM,EAAUN,EAAE,WACZK,EAAWL,EAAE,YACbE,EAAUF,EAAE,WACZO,EAAUP,EAAE,WAEZW,EAAS,SAACE,EAAWC,GCQnB,MAJe,OAAXA,IDJeA,EAAU,IAC7BT,EAASU,KAAKD,GACdE,QAAQC,IAAIC,MAAM,WCShB,MDRAX,GAAQQ,KAAKF,GACbX,EAAQa,KAAK,IAAIF,EAAU,KAC3BG,QAAQC,IAAIE,QAAQjB,EAAQkB,MAAO,WACjC,MAA+Bb,GAAQQ,SAAUF,EAAjDP,EAAQe,KAAKnB,EAAQmB,QAArB,YAENb,EAAclB,EAAQ,iBACpBqB,OAAQA,EACRW,QAAS,SAACpC,GCWR,MDXcqC,OAAMrC,MAExBwB,EAAS,SAACc,GCaR,MDbeA,GAAGC,KAAK,WAAaD,EAAGT,QAEzCZ,EAAWH,EAAE,QACbS,EAAYN,EAASuB,IAAI,WCcvB,MDd2BhB,GAAOV,EAAE2B,OAAOC,WAAW,KAExDxB,EACGyB,SAAS,SAAC/C,GACT,GAAAgD,GAAAC,CAMA,OANAD,GACgB,KAAXhD,EAAEkD,MACH,IAECC,OAAOC,aAAapD,EAAEkD,OAAOG,cAClCJ,EAAUD,EAAIF,WAAW,GACS,KAA9BnB,EAAU2B,MAAML,IAClBvB,EAAW6B,MAAMP,GACjBlB,KAFF,SAGD0B,QAAQ,SAACxD,GACR,MAAc,KAAXA,EAAEkD,OACHxB,EAAW+B,UACX3B,IACA9B,EAAE0D,kBAHJ,SAKJrC,EAASsC,MAAM,WCcb,MDbAjC,GAAW6B,MAAM3B,EAAOV,EAAE2B,QAC1Bf,MAEFA,EAAgB,WCad,MDZAT,GAASuC,KAAK,WACZ,MAAGlC,GAAWmC,SAASjC,EAAOV,EAAE2B,QAC9BA,KAAKiB,gBAAgB,YAErBjB,KAAKkB,aAAa,YAAY,MAEpCjC,IACAR,EAAY0C,YCmBXC,eAAe,IAAIC,GAAG,SAAS1D,EAAQ2D,GC5E1C,GAAAC,GAAA1C,CAAA0C,GAES5D,EAAQ,sBAFjBkB,EAaa,SAAC2C,GAEZ,GAAAC,GAAAC,EAAAV,EAAAW,EAAAjB,EAAAf,EAAAX,EAAA4C,EAAAhB,CDqKA,OCrKC5B,GAAAwC,EAAAxC,OAAQW,EAAA6B,EAAA7B,QAET8B,GACEI,KAAM,GACNC,OAAO,EACPC,IAAK,SAACC,EAAG1E,GD6EP,MAPS,OAALA,ICtEGA,GAAI,GACE,MAAA0E,IAAbhC,KAAC6B,KAAOG,GACRhC,KAAC8B,MAAQxE,EACT0C,KAAC6B,MACHI,UAAW,WD4ET,MC3EAjC,MAAC8B,QAGLd,EAAW,SAACb,GACV,GAAA+B,GAAAC,CAAA,OAAsB,MAAPhC,GAAR,EACG,MAAPA,GACD+B,EAAMT,EAAOM,MACbI,EAASZ,EAAOa,MAAMF,IACtBC,EAAQE,IAAIC,QAAUH,EAAQE,IAAIE,aAElCL,EAAMT,EAAOM,MAAQ5B,IAErBgC,EAASZ,EAAOa,MAAMF,IACtBC,EAAQE,IAAIC,QAFL,GAKX5B,EAAQ,SAACP,GAEP,MAD+B,MAAPA,GAAxBsB,EAAOM,IAAI5B,EAAM,IACP,MAAPA,EACDuB,KAGED,EAAOM,IADNN,EAAOQ,aAAgB9B,EAAIqC,MAAM,MACvBrC,EAEAsB,EAAOM,MAAQ5B,GAC5ByB,MAGJhB,EAAU,WACR,GAAA6B,EDsFA,OCtFAA,GAAQhB,EAAOM,MACfN,EAAOM,IAAIU,EAAMC,MAAA,EAAA,KACjBd,KAEFD,EAAQ,WDqFN,MCrFS3C,GAAO,KAElB4C,EAAU,WACR,GAAAM,GAAAC,CACA,OADAD,GAAMT,EAAOM,MACKG,EAAKS,QACvBR,EAASZ,EAAOa,MAAMF,GACnB,MAAAC,EAAAE,IAAAC,MACD1B,IAEA5B,EAAOmD,EAAOS,WALTjB,KAOTD,EAAO,WACL,GAAAQ,GAAAC,EAAAU,EAAAC,CACA,OADAZ,GAAMT,EAAOM,MACKG,EAAKS,QACvBR,EAASZ,EAAOa,MAAMF,GACZC,EAAOE,IAAIE,WAArB,QACAM,EAAWV,EAAOS,QAAOE,QAAQ,IAC9BD,EAAUP,MAMX3C,EAAQkD,EAASP,QALjBQ,EAASX,EAAOT,OAChB1C,EAAO6D,EAAUC,EAAOC,WAExBtB,EAAOM,IAAIe,EAAOE,YAAY,MARzBrB,KAYTA,KAEEX,SAAUA,EAAUN,MAAOA,EAAOE,QAASA,IArF/CU,EAuFOrD,QAAUY,IDwGdoE,qBAAqB,IAAIC,GAAG,SAASvF,EAAQ2D,GE/LhD,GAAA6B,GAAAC,EAAA1B,EAAA2B,EAAAC,EAAAlB,EAAAmB,EAAAX,EAAAY,CAAAH,GAEW1F,EAAQ,eAFnB4F,EAGS5F,EAAQ,0BAHjByF,EAKiB,SAACf,GAChB,GAAAoB,GAAAC,CAYA,OAZAA,GAAQ,SAAClG,GACP,GAAGA,EAAEmG,IAAL,CACE,GAAGnG,EAAEmG,IAAIxF,OACP,MACSuF,GAD0B,YAAhClG,EAAEmG,IAAInG,EAAEmG,IAAIxF,OAAS,GAAGyF,KACZpG,EAAEmG,IAAInG,EAAEmG,IAAIxF,OAAS,GAErBX,EAAEmG,IAAInG,EAAEmG,IAAIxF,OAAS,GACjC,IAAe,QAAZX,EAAEoG,KACR,MAAOF,GAAMlG,EAAEmG,KFwMnB,MEvMAnG,IAEFiG,EAAOC,EAAMrB,GACE,KAAZoB,EAAKE,KACNF,EAAKG,KAAO,cACZH,GAAYE,MAEZF,EAAKG,KAAO,gBACZH,GAAYE,MAvBhBvB,EAyBQ,SAACF,GACP,GAAAI,EAAA,KF2ME,ME1MAiB,GAAOnB,MAAMF,GADf,MAAA2B,GF8ME,ME5MIvB,GAAAuB,EACJL,EAA+BtB,EAAKI,KA7BxCkB,EA+BiC,SAACtB,EAAKI,GAGrC,GAAAD,GAAAyB,EAAAC,EAAAC,EAAAC,EAAAC,CAcc,KAddH,EAAS7B,EAETgC,EAAa,EAIVH,EAAOvB,MAAM,iBACduB,GAAU,MACVG,GAGFD,GAAcF,EAAOvB,MAAM,YAAcrE,OACzC2F,GAAeC,EAAOvB,MAAM,YAAcrE,OAC1C6F,EAAiBC,EAAaH,EACVG,IAAeH,GAAnCC,GAAU,GAaV,IAXqB,IAAlBC,GAAsC,IAAdE,IAGtBH,EAAOvB,MAAM,SACduB,GAAU,OACVG,GAECH,EAAOvB,MAAM,SACduB,GAAU,MACVG,GAAc,IAEfhC,IAAO6B,EACR,IAGE,IAFA1B,EAAMkB,EAAOnB,MAAM2B,GACoBC,EAAiB,IAAxD3B,EAAI2B,eAAiBA,GACfE,IAAe,GACnB7B,EAAIE,YAAa,EACjBa,EAAef,EACjB,OAAOA,GANT,MAAAwB,IFmNF,OE1MEvB,MAAOA,EAAM6B,UAvEjBb,EAyEY,SAACjB,EAAK+B,GAChB,GAAAV,EAAA,OAAerB,GACuB,MAAAA,EAAAC,MAA/B8B,EAAY9B,MAAMD,EAAIC,QAC7BoB,EAAQ,SAAClG,GFmNP,MEnNa4G,GAAY5G,EAAEoG,MAAMpG,EAAEmG,IAAKD,IAC1CU,EAAYC,KAAKX,EAAMrB,KAHhB,MA1ETX,EAgFO,SAACW,GACN,GAAAlF,GAAAU,CAAA,IAAG,MAAAwE,EAAAE,WFsND,OErNED,MAAO,wBAET,KFyNE,MExNAzE,GAAIwF,EACJC,EAAUjB,GACRC,MAAO,WFwNL,MExNQ,IACVgC,IAAK,SAACjH,GF0NJ,ME1NUQ,GAAE0G,OAAOlH,IACrBmH,IAAK,SAAC9G,EAAGgG,GF4NP,ME5NiBhG,GAAEqC,IAAI2D,GAAOe,OAAO,SAACC,EAAGvH,GF6NvC,ME7N6CU,GAAE2G,IAAIE,EAAGvH,MAC1DwH,MAAO,SAACxH,EAAGuG,GFgOT,MEhOmB7F,GAAE8G,MAAMjB,EAAMvG,KACnCyH,IAAK,SAAClH,EAAGgG,GFkOP,MElOiBhG,GAAEqC,IAAI2D,GAAOe,OAAO,SAACC,EAAGvH,GFmOvC,MEnO6CU,GAAE+G,IAAIF,EAAGvH,MAC1D0H,MAAO,SAACnH,GFsON,MEtOmBG,GAAEgH,MAAMnH,EAAE,GAAGiG,IAAKjG,EAAE,GAAGiG,IAAKjG,EAAE,GAAGiG,MACtDmB,KAAM,SAACpH,EAAGgG,GACR,GAAAqB,EAAA,OAAqD,KAAZrH,EAAES,OAApCN,EAAEmH,IAAItB,EAAMhG,EAAE,IAAKgG,EAAMhG,EAAE,MAGlCqH,EAAQrH,EAAEqC,IAAI2D,GAAOe,OAAO,SAAEC,EAAGvH,GAC/B,GAAAsG,EF+OA,OE/OAA,GAAOiB,EAAEA,EAAEvG,OAAS,GACjBsF,EAAKtF,OAAS,EAAOsF,EAAKwB,KAAK9H,GAAOuH,EAAEO,MAAM9H,IACjDuH,SAEFK,EACGhF,IAAI,SAAC5C,GF6ON,ME7OYU,GAAEmH,IAAI7H,EAAE,GAAIA,EAAE,IAAMU,EAAE0G,OAAO,MACxCE,OAAO,SAACC,EAAGvH,GF8OZ,ME9OkBU,GAAEmH,IAAIN,EAAGvH,OAC/B+E,IAAK,SAAC/E,EAAGuG,GFiPP,MEjPiBA,GAAMvG,IACzBkH,KAAM,SAAC/G,GFmPL,MEnPWA,MAtBjB,MAAAuG,GF8QE,MEvPI1G,GAAA0G,GACFvB,MAAQnF,EAAEgH,WA5GlBvB,EA+GS,SAACP,EAAKb,GAEb,GAAA0D,EF2QA,OE3QAA,GAAa,SAAC3H,GACZ,GAAAsH,GAAA/B,CACA,OADAA,GAASpB,EAAKW,GACgB,MAAAS,EAAAR,OAAvBA,MAAOQ,EAAOR,QACA/E,IAAKuF,EAAOE,aAAjCzF,GAAK,IAAIuF,GACT+B,EAAQ/B,EAAOqC,gBACKN,IAAS/B,EAAOE,aAApCzF,GAAK,IAAIsH,GACTtH,IAEF+F,EAAUjB,GACRC,MAAO,SAACnF,GFoQN,OEpQYmF,MAAOnF,IACrBiI,QAAS,WFwQP,MExQU,IACZd,IAAK,SAACjH,GF0QJ,ME1QU,GAAGA,GACfmH,IAAK,SAAC9G,EAAGgG,GF4QP,ME5QiBhG,GAAEqC,IAAI2D,GAAOe,OAAO,SAACC,EAAGvH,GF6QvC,ME7QgDuH,GAAE,IAAGvH,KACzDwH,MAAO,SAACxH,EAAGuG,GFgRT,MEhRmB,IAAIA,EAAMvG,IAC/ByH,IAAK,SAAClH,EAAGgG,GFkRP,MElRiBhG,GAAEqC,IAAI2D,GAAOe,OAAO,SAACC,EAAGvH,GFmRvC,MEnRgDuH,GAAE,KAAIvH,KAC1D0H,MAAO,SAACnH,EAAGgG,GFsRT,MEtRsBA,GAAMhG,EAAE,IAAG,IAAGgG,EAAMhG,EAAE,IAAG,IAAGgG,EAAMhG,EAAE,KAC5DoH,KAAM,SAACpH,EAAGgG,GAGR,GAAA7B,GAAAwD,CF0RA,OE1RAxD,GAAO,GACPwD,EAAK,WFuRH,MEvRMxD,GAAkB,MAARA,EAAiB,KAAU,KAC7CnE,EAAEqC,IAAI2D,GAAOe,OAAO,SAACC,EAAGvH,GFyRtB,MEzR4BuH,GAAIW,IAAOlI,KAC3C+E,IAAK,SAAC/E,EAAGuG,GF4RP,ME5RiB,IAAIA,EAAMvG,GAAG,KAChCkH,KAAM,SAAC9G,GAEL,MADAA,GAAIA,EAAE+H,QAAQ,OAAQ,KAAKA,QAAQ,MAAO,MAC1C,MAAA9D,EAAGA,EAASsB,OAAA,QAAYoC,EAAW3H,GAAOA,MA1IhD4F,EAAA,WA6Ie,QAAAA,GAACoC,GAAAvF,KAACqC,IAADkD,EFgTd,MEhTApC,GAAAqC,UACA9D,KAAM,WFwSJ,MExSOA,GAAK1B,KAACqC,MADfc,EAAAqC,UAEA5C,OAAQ,SAACpB,GF2SP,ME3SmBoB,GAAO5C,KAACqC,IAAKb,IF8S3B2B,KE7bT7B,EAiJOrD,SACLmE,MAAO,SAACjF,GFiTN,MEjTgB,IAAAgG,GAAOf,EAAMjF,QFuT9BsI,cAAc,EAAEC,yBAAyB,IAAIC,GAAG,SAAShI,EAAQ2D,GGzcpEA,EAAArD,QAAA,WAOA,QAAA2H,GAAAC,EAAAC,GACA,QAAAC,KAAA/F,KAAAgG,YAAAH,EACAE,EAAAP,UAAAM,EAAAN,UACAK,EAAAL,UAAA,GAAAO,GAGA,QAAAE,GAAA9B,EAAA+B,EAAAC,EAAAC,EAAAC,EAAAC,GACAtG,KAAAmE,QAAAA,EACAnE,KAAAkG,SAAAA,EACAlG,KAAAmG,MAAAA,EACAnG,KAAAoG,OAAAA,EACApG,KAAAqG,KAAAA,EACArG,KAAAsG,OAAAA,EAEAtG,KAAAuG,KAAA,cAKA,QAAAnE,GAAA1B,GA0FA,QAAA8F,GAAAC,GACA,QAAAC,GAAAC,EAAAC,EAAAC,GACA,GAAAnC,GAAAoC,CAEA,KAAApC,EAAAkC,EAAAC,EAAAnC,EAAAA,IACAoC,EAAApG,EAAAqG,OAAArC,GACA,OAAAoC,GACAH,EAAAK,QAAAL,EAAAN,OACAM,EAAAL,OAAA,EACAK,EAAAK,QAAA,GACA,OAAAF,GAAA,WAAAA,GAAA,WAAAA,GACAH,EAAAN,OACAM,EAAAL,OAAA,EACAK,EAAAK,QAAA,IAEAL,EAAAL,SACAK,EAAAK,QAAA,GAcA,MATAC,MAAAR,IACAQ,GAAAR,IACAQ,GAAA,EACAC,IAAAb,KAAA,EAAAC,OAAA,EAAAU,QAAA,IAEAN,EAAAQ,GAAAD,GAAAR,GACAQ,GAAAR,GAGAS,GAGA,QAAAC,GAAAjB,GACAkB,GAAAC,KAEAA,GAAAD,KACAA,GAAAC,GACAC,OAGAA,GAAArC,KAAAiB,IAGA,QAAAqB,GAAApD,EAAA+B,EAAAO,GACA,QAAAe,GAAAtB,GACA,GAAAtI,GAAA,CAYA,KAVAsI,EAAAuB,KAAA,SAAA/J,EAAAgK,GACA,MAAAhK,GAAAiK,YAAAD,EAAAC,YACA,GACAjK,EAAAiK,YAAAD,EAAAC,YACA,EAEA,IAIA/J,EAAAsI,EAAA/H,QACA+H,EAAAtI,EAAA,KAAAsI,EAAAtI,GACAsI,EAAA0B,OAAAhK,EAAA,GAEAA,IAKA,QAAAiK,GAAA3B,EAAAC,GACA,QAAA2B,GAAAvK,GACA,QAAAwK,GAAAjB,GAAA,MAAAA,GAAA7G,WAAA,GAAA+C,SAAA,IAAAxC,cAEA,MAAAjD,GACA+H,QAAA,MAAA,QACAA,QAAA,KAAA,OACAA,QAAA,QAAA,OACAA,QAAA,MAAA,OACAA,QAAA,MAAA,OACAA,QAAA,MAAA,OACAA,QAAA,MAAA,OACAA,QAAA,2BAAA,SAAAwB,GAAA,MAAA,OAAAiB,EAAAjB,KACAxB,QAAA,wBAAA,SAAAwB,GAAA,MAAA,MAAAiB,EAAAjB,KACAxB,QAAA,mBAAA,SAAAwB,GAAA,MAAA,OAAAiB,EAAAjB,KACAxB,QAAA,mBAAA,SAAAwB,GAAA,MAAA,MAAAiB,EAAAjB,KAGA,GACAkB,GAAAC,EAAArK,EADAsK,EAAA,GAAAC,OAAAjC,EAAA/H,OAGA,KAAAP,EAAA,EAAAA,EAAAsI,EAAA/H,OAAAP,IACAsK,EAAAtK,GAAAsI,EAAAtI,GAAA+J,WAWA,OARAK,GAAA9B,EAAA/H,OAAA,EACA+J,EAAAxF,MAAA,EAAA,IAAA0F,KAAA,MACA,OACAF,EAAAhC,EAAA/H,OAAA,GACA+J,EAAA,GAEAD,EAAA9B,EAAA,IAAA2B,EAAA3B,GAAA,IAAA,eAEA,YAAA6B,EAAA,QAAAC,EAAA,UAGA,GAAAI,GAAA7B,EAAAC,GACAN,EAAAM,EAAA/F,EAAAvC,OAAAuC,EAAAqG,OAAAN,GAAA,IAMA,OAJA,QAAAP,GACAsB,EAAAtB,GAGA,GAAAD,GACA,OAAA9B,EAAAA,EAAA0D,EAAA3B,EAAAC,GACAD,EACAC,EACAM,EACA4B,EAAAhC,KACAgC,EAAA/B,QAIA,QAAAgC,KACA,GAAAC,EAIA,OAFAA,GAAAC,IAKA,QAAAA,KACA,GAAAD,GAAAE,EAAAC,EAAAC,EAAAC,EAAAC,CAKA,IAHAC,KACAP,EAAAlB,GACAoB,EAAAM,IACAN,IAAAO,EAAA,CAgCA,GA/BAN,KACAC,EAAAtB,GACA,KAAA3G,EAAAT,WAAAoH,KACAuB,EAAAK,EACA5B,OAEAuB,EAAAI,EACA,IAAAF,IAAA3B,EAAA+B,IAEAN,IAAAI,IACA,KAAAtI,EAAAT,WAAAoH,KACAuB,EAAAO,EACA9B,OAEAuB,EAAAI,EACA,IAAAF,IAAA3B,EAAAiC,KAGAR,IAAAI,GACAH,EAAAE,IACAF,IAAAG,GACAJ,GAAAA,EAAAC,GACAF,EAAAC,IAEAvB,GAAAsB,EACAA,EAAAU,KAGAhC,GAAAsB,EACAA,EAAAU,GAEAV,IAAAK,EACA,KAAAL,IAAAK,GACAN,EAAAzD,KAAA0D,GACAA,EAAAtB,GACA,KAAA3G,EAAAT,WAAAoH,KACAuB,EAAAK,EACA5B,OAEAuB,EAAAI,EACA,IAAAF,IAAA3B,EAAA+B,IAEAN,IAAAI,IACA,KAAAtI,EAAAT,WAAAoH,KACAuB,EAAAO,EACA9B,OAEAuB,EAAAI,EACA,IAAAF,IAAA3B,EAAAiC,KAGAR,IAAAI,GACAH,EAAAE,IACAF,IAAAG,GACAJ,GAAAA,EAAAC,GACAF,EAAAC,IAEAvB,GAAAsB,EACAA,EAAAU,KAGAhC,GAAAsB,EACAA,EAAAU,OAIAX,GAAAW,CAEAX,KAAAM,GACAM,GAAAf,EACAE,EAAAc,EAAAd,EAAAC,GACAH,EAAAE,IAEApB,GAAAkB,EACAA,EAAAc,OAGAhC,IAAAkB,EACAA,EAAAc,CAWA,OATAd,KAAAS,IACAT,EAAAQ,KAEAD,KACAP,IAAAS,IACAP,EAAAO,EACA,IAAAF,IAAA3B,EAAAqC,IAGAjB,EAGA,QAAAQ,KACA,GAAAR,GAAAE,EAAAC,EAAAC,EAAAC,EAAAC,CAKA,IAHAC,KACAP,EAAAlB,GACAoB,EAAAgB,IACAhB,IAAAO,EAAA,CAuBA,GAtBAN,KACAC,EAAAtB,GACA,KAAA3G,EAAAT,WAAAoH,KACAuB,EAAAc,EACArC,OAEAuB,EAAAI,EACA,IAAAF,IAAA3B,EAAAwC,IAEAf,IAAAI,GACAH,EAAAY,IACAZ,IAAAG,GACAJ,GAAAA,EAAAC,GACAF,EAAAC,IAEAvB,GAAAsB,EACAA,EAAAU,KAGAhC,GAAAsB,EACAA,EAAAU,GAEAV,IAAAK,EACA,KAAAL,IAAAK,GACAN,EAAAzD,KAAA0D,GACAA,EAAAtB,GACA,KAAA3G,EAAAT,WAAAoH,KACAuB,EAAAc,EACArC,OAEAuB,EAAAI,EACA,IAAAF,IAAA3B,EAAAwC,IAEAf,IAAAI,GACAH,EAAAY,IACAZ,IAAAG,GACAJ,GAAAA,EAAAC,GACAF,EAAAC,IAEAvB,GAAAsB,EACAA,EAAAU,KAGAhC,GAAAsB,EACAA,EAAAU,OAIAX,GAAAW,CAEAX,KAAAM,GACAM,GAAAf,EACAE,EAAAmB,EAAAnB,EAAAC,GACAH,EAAAE,IAEApB,GAAAkB,EACAA,EAAAc,OAGAhC,IAAAkB,EACAA,EAAAc,CAWA,OATAd,KAAAS,IACAT,EAAAkB,KAEAX,KACAP,IAAAS,IACAP,EAAAO,EACA,IAAAF,IAAA3B,EAAA0C,IAGAtB,EAGA,QAAAkB,KACA,GAAAlB,GAAAE,EAAAC,EAAAC,EAAAC,EAAAC,CAKA,IAHAC,KACAP,EAAAlB,GACAoB,EAAAqB,IACArB,IAAAO,EAAA,CAuBA,GAtBAN,KACAC,EAAAtB,GACA,KAAA3G,EAAAT,WAAAoH,KACAuB,EAAAmB,EACA1C,OAEAuB,EAAAI,EACA,IAAAF,IAAA3B,EAAA6C,IAEApB,IAAAI,GACAH,EAAAiB,IACAjB,IAAAG,GACAJ,GAAAA,EAAAC,GACAF,EAAAC,IAEAvB,GAAAsB,EACAA,EAAAU,KAGAhC,GAAAsB,EACAA,EAAAU,GAEAV,IAAAK,EACA,KAAAL,IAAAK,GACAN,EAAAzD,KAAA0D,GACAA,EAAAtB,GACA,KAAA3G,EAAAT,WAAAoH,KACAuB,EAAAmB,EACA1C,OAEAuB,EAAAI,EACA,IAAAF,IAAA3B,EAAA6C,IAEApB,IAAAI,GACAH,EAAAiB,IACAjB,IAAAG,GACAJ,GAAAA,EAAAC,GACAF,EAAAC,IAEAvB,GAAAsB,EACAA,EAAAU,KAGAhC,GAAAsB,EACAA,EAAAU,OAIAX,GAAAW,CAEAX,KAAAM,GACAM,GAAAf,EACAE,EAAAwB,EAAAxB,EAAAC,GACAH,EAAAE,IAEApB,GAAAkB,EACAA,EAAAc,OAGAhC,IAAAkB,EACAA,EAAAc,CA2DA,OAzDAd,KAAAS,IACAT,EAAAlB,GACAoB,EAAAyB,IACAzB,IAAAO,GACA,KAAAtI,EAAAT,WAAAoH,KACAqB,EAAAyB,EACA9C,OAEAqB,EAAAM,EACA,IAAAF,IAAA3B,EAAAiD,IAEA1B,IAAAM,GACAL,EAAA0B,IACA1B,IAAAK,GACA,KAAAtI,EAAAT,WAAAoH,KACAuB,EAAAmB,EACA1C,OAEAuB,EAAAI,EACA,IAAAF,IAAA3B,EAAA6C,IAEApB,IAAAI,GACAH,EAAAqB,IACArB,IAAAG,GACAM,GAAAf,EACAE,EAAA6B,EAAA7B,EAAAE,EAAAE,GACAN,EAAAE,IAEApB,GAAAkB,EACAA,EAAAc,KAGAhC,GAAAkB,EACAA,EAAAc,KAGAhC,GAAAkB,EACAA,EAAAc,KAGAhC,GAAAkB,EACAA,EAAAc,KAGAhC,GAAAkB,EACAA,EAAAc,GAEAd,IAAAS,IACAT,EAAAuB,MAGAhB,KACAP,IAAAS,IACAP,EAAAO,EACA,IAAAF,IAAA3B,EAAAoD,IAGAhC,EAGA,QAAAuB,KACA,GAAAvB,GAAAE,EAAAC,EAAAC,EAAAC,CAsEA,OApEAE,MACAP,EAAA2B,IACA3B,IAAAS,IACAT,EAAAlB,GACA,KAAA3G,EAAAT,WAAAoH,KACAoB,EAAAU,EACA9B,OAEAoB,EAAAO,EACA,IAAAF,IAAA3B,EAAAiC,IAEAX,IAAAO,IACA,KAAAtI,EAAAT,WAAAoH,KACAoB,EAAAQ,EACA5B,OAEAoB,EAAAO,EACA,IAAAF,IAAA3B,EAAA+B,KAGAT,IAAAO,IACAP,EAAA+B,GAEA/B,IAAAO,GACA,KAAAtI,EAAAT,WAAAoH,KACAqB,EAAA+B,EACApD,OAEAqB,EAAAM,EACA,IAAAF,IAAA3B,EAAAuD,IAEAhC,IAAAM,GACAL,EAAAH,IACAG,IAAAK,GACA,KAAAtI,EAAAT,WAAAoH,KACAuB,EAAA+B,EACAtD,OAEAuB,EAAAI,EACA,IAAAF,IAAA3B,EAAAyD,IAEAhC,IAAAI,GACAM,GAAAf,EACAE,EAAAoC,EAAApC,EAAAE,GACAJ,EAAAE,IAEApB,GAAAkB,EACAA,EAAAc,KAGAhC,GAAAkB,EACAA,EAAAc,KAGAhC,GAAAkB,EACAA,EAAAc,KAGAhC,GAAAkB,EACAA,EAAAc,IAGAP,KACAP,IAAAS,IACAP,EAAAO,EACA,IAAAF,IAAA3B,EAAA2D,IAGAvC,EAGA,QAAA2B,KACA,GAAA3B,GAAAE,EAAAC,EAAAC,CAuBA,IArBAG,KACAP,EAAAlB,GACA,KAAA3G,EAAAT,WAAAoH,KACAoB,EAAAU,EACA9B,OAEAoB,EAAAO,EACA,IAAAF,IAAA3B,EAAAiC,IAEAX,IAAAO,IACA,KAAAtI,EAAAT,WAAAoH,KACAoB,EAAAQ,EACA5B,OAEAoB,EAAAO,EACA,IAAAF,IAAA3B,EAAA+B,KAGAT,IAAAO,IACAP,EAAA+B,GAEA/B,IAAAO,EAAA,CASA,GARAN,KACAqC,EAAAC,KAAAtK,EAAAqG,OAAAM,MACAsB,EAAAjI,EAAAqG,OAAAM,IACAA,OAEAsB,EAAAK,EACA,IAAAF,IAAA3B,EAAA8D,IAEAtC,IAAAK,EACA,KAAAL,IAAAK,GACAN,EAAAzD,KAAA0D,GACAoC,EAAAC,KAAAtK,EAAAqG,OAAAM,MACAsB,EAAAjI,EAAAqG,OAAAM,IACAA,OAEAsB,EAAAK,EACA,IAAAF,IAAA3B,EAAA8D,QAIAvC,GAAAW,CAEAX,KAAAM,GACAM,GAAAf,EACAE,EAAAyC,EAAAzC,EAAAC,GACAH,EAAAE,IAEApB,GAAAkB,EACAA,EAAAc,OAGAhC,IAAAkB,EACAA,EAAAc,CAQA,OANAP,MACAP,IAAAS,IACAP,EAAAO,EACA,IAAAF,IAAA3B,EAAAgE,IAGA5C,EAGA,QAAA8B,KACA,GAAA9B,GAAAE,EAAAC,CAYA,IAVAI,KACAP,EAAAlB,GACAoB,KACAsC,EAAAC,KAAAtK,EAAAqG,OAAAM,MACAqB,EAAAhI,EAAAqG,OAAAM,IACAA,OAEAqB,EAAAM,EACA,IAAAF,IAAA3B,EAAA8D,IAEAvC,IAAAM,EACA,KAAAN,IAAAM,GACAP,EAAAxD,KAAAyD,GACAqC,EAAAC,KAAAtK,EAAAqG,OAAAM,MACAqB,EAAAhI,EAAAqG,OAAAM,IACAA,OAEAqB,EAAAM,EACA,IAAAF,IAAA3B,EAAA8D,QAIAxC,GAAAY,CAaA,OAXAZ,KAAAO,IACAM,GAAAf,EACAE,EAAA2C,GAAA3C,IAEAF,EAAAE,EACAK,KACAP,IAAAS,IACAP,EAAAO,EACA,IAAAF,IAAA3B,EAAAkE,KAGA9C,EAIA,QAAAjE,GAAAjH,GAAA,OAAAuG,KAAA,MAAAD,IAAAtG,GACA,QAAAmH,GAAA9G,GAAA,OAAAkG,KAAA,MAAAD,IAAAjG,GACA,QAAAkH,GAAAlH,GAAA,OAAAkG,KAAA,MAAAD,IAAAjG,GACA,QAAAoH,GAAApH,GAAA,OAAAkG,KAAA,OAAAD,IAAAjG,GACA,QAAAmH,GAAAnH,GAAA,OAAAkG,KAAA,QAAAD,IAAAjG,GACA,QAAAwE,GAAA/E,GAAA,OAAAyG,KAAA,MAAAD,IAAAxG,GAEA,QAAAwH,GAAAxH,GAAA,OAAAyG,KAAA,QAAAD,IAAAxG,GAEA,QAAAmO,GAAA5N,GACA,MAAAA,GAAAqC,IAAA,SAAA5C,GACA,MAAA,MAAAA,EAAA,GAAAwH,EAAAxH,EAAA,IAAAA,EAAA,KAjtBA,GAmDAoO,GAnDA/J,EAAAgK,UAAArN,OAAA,EAAAqN,UAAA,MAEAxC,KAEAyC,GAAAC,EAAApD,GACAqD,EAAArD,EAEAkB,GAAA5F,KAAA,QAAA+D,YAAA,cACA0B,EAAAL,EAEAC,EAAA,IACAC,GAAAtF,KAAA,UAAAnB,MAAA,IAAAkF,YAAA,OACAwB,EAAA,IACAC,GAAAxF,KAAA,UAAAnB,MAAA,IAAAkF,YAAA,OACA4B,EAAA,SAAAqC,EAAAC,GAAA,MAAArH,IAAAoH,GAAAE,OAAAR,EAAAO,MACAhC,GAAAjG,KAAA,QAAA+D,YAAA,QACA+B,EAAA,IACAC,GAAA/F,KAAA,UAAAnB,MAAA,IAAAkF,YAAA,OACAiC,EAAA,SAAAgC,EAAAC,GAAA,MAAAjH,IAAAgH,GAAAE,OAAAR,EAAAO,MACAtB,GAAA3G,KAAA,QAAA+D,YAAA,YACAoC,EAAA,IACAC,GAAApG,KAAA,UAAAnB,MAAA,IAAAkF,YAAA,OACAsC,EAAA,SAAA2B,EAAAC,GAAA,MAAA/G,IAAA8G,GAAAE,OAAAR,EAAAO,MACA1B,EAAA,IACAC,GAAAxG,KAAA,UAAAnB,MAAA,IAAAkF,YAAA,OACA2C,EAAA,SAAAyB,EAAAH,EAAAC,GAAA,MAAAhH,IAAAkH,EAAAH,EAAAC,KACAf,GAAAlH,KAAA,QAAA+D,YAAA,UACA6C,EAAA,KACAC,EAAA,IACAC,GAAA9G,KAAA,UAAAnB,MAAA,IAAAkF,YAAA,OACAgD,EAAA,IACAC,GAAAhH,KAAA,UAAAnB,MAAA,IAAAkF,YAAA,OACAkD,EAAA,SAAAmB,EAAAC,GACA,GAAA3O,GAAA4E,EAAA+J,EACA,OAAA,MAAAD,EAAArH,EAAArH,GAAAA,GAEA6N,GAAAvH,KAAA,QAAA+D,YAAA,WACAoD,EAAA,SACAE,GAAArH,KAAA,QAAAnB,MAAA,QAAAkF,YAAA,SACAuD,EAAA,SAAAc,EAAAE,GAAA,MAAA5H,GAAA6H,UAAAH,GAAA,IAAAE,EAAA9D,KAAA,IAAA,MACAiD,IAAAzH,KAAA,QAAA+D,YAAA,oBACAyD,GAAA,SAAAc,GAAA,MAAA5H,GAAA6H,SAAAD,EAAA9D,KAAA,IAAA,MAEAf,GAAA,EACAiC,GAAA,EACArC,GAAA,EACAC,IAAAb,KAAA,EAAAC,OAAA,EAAAU,QAAA,GACAI,GAAA,EACAE,MACAwB,GAAA,CAIA,IAAA,aAAAtH,GAAA,CACA,KAAAA,EAAA4K,YAAAX,IACA,KAAA,IAAA3N,OAAA,mCAAA0D,EAAA4K,UAAA,KAGAT,GAAAF,EAAAjK,EAAA4K,WA8pBA,GAFAb,EAAAI,IAEAJ,IAAAvC,GAAA3B,KAAA3G,EAAAvC,OACA,MAAAoN,EAMA,MAJAA,KAAAvC,GAAA3B,GAAA3G,EAAAvC,QACAgJ,GAAAvD,KAAA,MAAA+D,YAAA,iBAGAJ,EAAA,KAAAD,GAAAF,IAIA,MAtuBAxB,GAAAK,EAAAnI,QAuuBAmI,YAAAA,EACA7D,MAAAA,WH6cMiK,GAAG,SAAS1O,EAAQ2D,GI7sC1B,GAAAgL,GAAAC,EAAAC,CAAAA,GAEM,SAACnP,EAAGoP,GACR,GAAAnP,EACA,KADAA,EAAI,EACO,IAALmP,GACJnP,EAAID,EAAIoP,EACRpP,EAAIoP,EACJA,EAAInP,CJmtCN,OIltCAoP,MAAKC,IAAItP,IARXkP,EAUW,GAAAzO,OAAM,qBAVjBwO,EAAA,WAce,QAAAA,GAACjP,EAAGoP,GACf,GAAAzH,GAAA4H,CAAA,IJmtCS,MAALH,IIptCWA,EAAI,GACA,IAALA,EAAd,KAAMF,EACmB,GAAJE,IAArBG,IAAUvP,GAAIoP,GAAbpP,EAAAuP,EAAA,GAAGH,EAAAG,EAAA,IACJ5H,EAAMwH,EAAInP,EAAGoP,GACbzM,KAAC3C,EAAIA,EAAI2H,EACThF,KAACyM,EAAIA,EAAIzH,EJuxCX,MI5xCAsH,GAAA9G,UAOAqH,SAAU,WJ4tCR,MI5tCW7M,MAAC3C,EAAI2C,KAACyM,GAPnBH,EAAA9G,UASAzC,QAAS,WJ8tCP,MI9tCU/C,MAAC3C,EAAI2C,KAACyM,GATlBH,EAAA9G,UAWAxC,SAAU,WAAG,MAAS,KAANhD,KAACyM,EAAY,GAAGzM,KAAC3C,EAAY2C,KAAC3C,EAAE,IAAG2C,KAACyM,GAXpDH,EAAA9G,UAaAL,cAAe,WACb,MAAGnF,MAAC6M,WACF7M,KAACgD,WACKhD,KAAC3C,EAAI2C,KAACyM,IAAK,EACjB,GAAEC,KAAAI,MAAC9M,KAAC3C,EAAK2C,KAACyM,GAERC,KAAAI,MAAC9M,KAAC3C,EAAK2C,KAACyM,GAAE,IAAGzM,KAAC3C,EAAI2C,KAACyM,EAAE,IAAGzM,KAACyM,GAE/BH,EAAC/H,OAAQ,SAAClH,EAAGoP,GJwuCX,MIxuCqB,IAAAH,GAASjP,EAAGoP,IAEnCH,EAACzH,MAAO,SAACkI,EAAG1P,EAAGoP,GJ0uCb,MI1uCmBzM,MAACuE,OAAOlH,EAAI0P,EAAEN,EAAGA,IAEtCH,EAAC9H,IAAK,SAACxG,EAAGV,GACR,GAAAI,GAAAgK,EAAAsF,EAAAP,EAAAG,CJ6uCA,OI7uCAA,IAAgB5O,EAAEX,EAAGW,EAAEyO,EAAGnP,EAAED,EAAGC,EAAEmP,GAAhC/O,EAAAkP,EAAA,GAAGlF,EAAAkF,EAAA,GAAGI,EAAAJ,EAAA,GAAGH,EAAAG,EAAA,GACV5M,KAACuE,OAAO7G,EAAE+O,EAAIO,EAAEtF,EAAGA,EAAE+E,IAEvBH,EAAC3H,MAAQ,SAAC9G,GACR,GAAA4O,GAAApP,EAAAuP,CJ+uCA,OI/uCAA,IAAU/O,EAAER,EAAGQ,EAAE4O,GAAhBpP,EAAAuP,EAAA,GAAGH,EAAAG,EAAA,GACJ5M,KAACuE,QAAOlH,EAAIoP,IAEdH,EAAC1H,IAAM,SAAC5G,EAAGV,GACT,GAAAI,GAAAgK,EAAAsF,EAAAP,EAAAG,CJivCA,OIjvCAA,IAAgB5O,EAAEX,EAAGW,EAAEyO,EAAGnP,EAAED,EAAGC,EAAEmP,GAAhC/O,EAAAkP,EAAA,GAAGlF,EAAAkF,EAAA,GAAGI,EAAAJ,EAAA,GAAGH,EAAAG,EAAA,GACV5M,KAACuE,OAAO7G,EAAEsP,EAAGtF,EAAE+E,IAEjBH,EAACtH,IAAM,SAAChH,EAAGV,GACT,GAAAI,GAAAgK,EAAAsF,EAAAP,EAAAG,CJmvCA,OInvCAA,IAAgB5O,EAAEX,EAAGW,EAAEyO,EAAGnP,EAAED,EAAGC,EAAEmP,GAAhC/O,EAAAkP,EAAA,GAAGlF,EAAAkF,EAAA,GAAGI,EAAAJ,EAAA,GAAGH,EAAAG,EAAA,GACV5M,KAACuE,OAAO7G,EAAE+O,EAAG/E,EAAEsF,IJqvCVV,KI1yCThL,EAuDOrD,QAAUqO,YJ2vCN","file":"main.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","### global MathJax,jQuery,require ###\n\n$ = jQuery\n\n$ ->\n  $calculator = $ '#calculator'\n  $output = $ '#output'\n  $decimal = $ '#decimal'\n  $buffer = $ '#buffer' # buffer for MathJax\n  $parsed = $ '#parsed' # for debugging\n\n  output = (asciiMath, decimal = '') ->\n    $decimal.text decimal\n    MathJax.Hub.Queue ->\n      $parsed.text asciiMath\n      $buffer.text \"`#{asciiMath}`\"\n      MathJax.Hub.Typeset $buffer.get(), ->\n        $output.html $buffer.html() if $parsed.text() == asciiMath\n\n  calculator = (require './calculator')\n    output: output\n    onError: (s) -> alert s\n\n  getKey = ($b) -> $b.data('symbol') or $b.text()\n\n  $buttons = $ '.btn'\n  charCodes = $buttons.map -> (getKey $(this)).charCodeAt 0\n\n  $calculator\n    .keypress (e) ->\n      key =\n        if e.which is 13 # <ENTER>\n          '='\n        else\n          (String.fromCharCode e.which).toUpperCase()\n      keyCode = key.charCodeAt 0\n      if (charCodes.index keyCode) isnt -1\n        calculator.input key\n        toggleButtons()\n    .keydown (e) ->\n      if e.which is 8 # <BACKSPACE>\n        calculator.uninput()\n        toggleButtons()\n        e.preventDefault() # don't allow back navigation with <BACKSPACE>\n\n  $buttons.click ->\n    calculator.input getKey $(this)\n    toggleButtons()\n\n  toggleButtons = ->\n    $buttons.each ->\n      if calculator.canInput getKey $(this)\n        this.removeAttribute 'disabled'\n      else\n        this.setAttribute 'disabled', true\n\n  toggleButtons()\n  $calculator.focus()\n",null,"### global module,require ###\n\nParser = require './fractions-parser'\n\n# (options::{\n#   output: (asciiMath::Str, decimal::Num?) -> None\n#   onError: (message::Str) -> None\n# }) ->\n# {\n#   canInput: (key::Str) -> Bool\n#   input: (key::Str) -> None\n#   uninput: (None) -> None\n# }\ncalculator = (options) ->\n\n  {output, onError} = options\n\n  $input =\n    curr: ''\n    isRes: false\n    val: (v, r = false) ->\n      @curr = v if v?\n      @isRes = r\n      @curr\n    hasResult: ->\n      @isRes\n\n  # canInput :: (key::Str) -> Bool\n  canInput = (key) ->\n    return true if key is 'C' # \"clear\"\n    if key is '='\n      exp = $input.val()\n      parsed = Parser.parse exp\n      !parsed.ast.error and !parsed.ast.incomplete\n    else\n      exp = $input.val() + key\n      return true if !exp\n      parsed = Parser.parse exp\n      !parsed.ast.error\n\n  # input :: (key::Str) -> None\n  input = (key) ->\n    $input.val(key = '') if key is 'C' # \"clear\"\n    if key is '='\n      calc()\n    else\n      if $input.hasResult() and key.match /\\d/\n        $input.val key\n      else\n        $input.val $input.val() + key\n      process()\n\n  # uninput :: (None) -> None\n  uninput = ->\n    value = $input.val()\n    $input.val value[0...-1] # trim last element\n    process()\n\n  clear = -> output ''\n\n  process = ->\n    exp = $input.val()\n    return clear() if !exp.trim()\n    parsed = Parser.parse exp\n    if parsed.ast.error?\n      uninput()\n    else\n      output parsed.render()\n\n  calc = ->\n    exp = $input.val()\n    return clear() if !exp.trim()\n    parsed = Parser.parse exp\n    return if parsed.ast.incomplete\n    rendered = parsed.render result: yes\n    if !rendered.error\n      result = parsed.calc()\n      output rendered, result.toFloat()\n      # move the result to the input\n      $input.val result.toString(), true\n    else\n      onError rendered.error\n\n  clear()\n\n  { canInput: canInput, input: input, uninput: uninput }\n\nmodule.exports = calculator\n","### global module,require ###\n\nfraction = require './fractions'\nparser = require './fractions-peg-parser'\n\naddMissingTerm = (ast) ->\n  recur = (o) ->\n    if o.arg\n      if o.arg.length\n        if o.arg[o.arg.length - 1].type is 'missing'\n          return recur o.arg[o.arg.length - 2]\n        else\n          return recur o.arg[o.arg.length - 1]\n      else if o.type isnt 'num'\n        return recur o.arg\n    o\n\n  last = recur ast\n  if last.arg == -1\n    last.type = 'minus'\n    delete last.arg\n  else\n    last.type = 'missing'\n    delete last.arg\n\nparse = (exp) ->\n  try\n    parser.parse exp\n  catch error\n    tryParseAsIncompleteExpression exp, error\n\ntryParseAsIncompleteExpression = (exp, error) ->\n\n  # try to create a valid expression\n  newExp = exp\n\n  termsAdded = 0\n\n  # if it ends with a non-number (except a closing parenthesis or a space),\n  # see if adding a number works\n  if newExp.match /[^\\d\\)\\s]+$/\n    newExp += '1'\n    ++termsAdded\n\n  # balance close parenthesis\n  openParens = (newExp.match(/\\(/g) or []).length\n  closeParens = (newExp.match(/\\)/g) or []).length\n  numParensAdded = openParens - closeParens\n  newExp += ')' while openParens-- > closeParens\n\n  if numParensAdded is 0 and termsAdded is 0\n    # mixed numbers\n    # if it ends with a number, see if adding a denominator works\n    if newExp.match /\\d$/\n      newExp += '/1'\n      ++termsAdded\n    # if it ends with a space, see if adding a fraction works\n    if newExp.match /\\s$/\n      newExp += '1/1'\n      termsAdded += 2\n\n  if exp != newExp\n    try\n      ast = parser.parse newExp\n      ast.numParensAdded = numParensAdded if numParensAdded > 0\n      while termsAdded-- > 0\n        ast.incomplete = true\n        addMissingTerm ast\n      return ast\n\n  # couldn't \"fix\" the expression\n  { error: error.message }\n\ninterpret = (ast, interpreter) ->\n  return null if !ast\n  return interpreter.error ast.error if ast.error?\n  recur = (o) -> interpreter[o.type] o.arg, recur\n  interpreter.post recur ast\n\n# calculate AST result\ncalc = (ast) ->\n  if ast.incomplete?\n    { error: 'incomplete expression' }\n  else\n    try\n      f = fraction\n      interpret ast,\n        error: -> ''\n        num: (n) -> f.create n\n        add: (a, recur) -> a.map(recur).reduce (p, e) -> f.add p, e\n        minus: (e, recur) -> f.minus recur e\n        mul: (a, recur) -> a.map(recur).reduce (p, e) -> f.mul p, e\n        mixed: (a, recur) -> f.mixed a[0].arg, a[1].arg, a[2].arg\n        over: (a, recur) ->\n          return f.div recur(a[0]), recur(a[1]) if a.length == 2\n          # do pair-wise association,\n          # e.g. \"1 / 2 / 3 / 4 / 5\" => \"(1 / 2) / (3 / 4) / 5\"\n          pairs = a.map(recur).reduce ((p, e) ->\n            last = p[p.length - 1]\n            if last.length < 2 then last.push e else p.push [e]\n            p\n          ), [[]]\n          pairs\n            .map (e) -> f.div e[0], e[1] or f.create(1)\n            .reduce (p, e) -> f.div p, e\n        exp: (e, recur) -> recur e\n        post: (r) -> r\n    catch e\n      { error : e.message }\n\n# render AST as AsciiMath\nrender = (ast, options) ->\n\n  withResult = (s) ->\n    result = calc(ast)\n    return error: result.error if result.error?\n    s += \"=#{result}\" if s != result.toString()\n    mixed = result.toMixedString()\n    s += \"=#{mixed}\" if mixed != result.toString()\n    s\n\n  interpret ast,\n    error: (e) -> error: e\n    missing: -> ''\n    num: (n) -> \"#{n}\"\n    add: (a, recur) -> a.map(recur).reduce (p, e) -> \"#{p}+#{e}\"\n    minus: (e, recur) -> \"-#{recur(e)}\"\n    mul: (a, recur) -> a.map(recur).reduce (p, e) -> \"#{p}xx#{e}\"\n    mixed: (a, recur) -> \"#{recur a[0]} #{recur a[1]}/#{recur a[2]}\"\n    over: (a, recur) ->\n      # do pair-wise association,\n      # e.g. \"1 / 2 / 3 / 4 / 5\" => \"(1 / 2) -: (3 / 4) -: 5\"\n      curr = ''\n      op = -> curr = if curr == '/' then '-:' else '/'\n      a.map(recur).reduce (p, e) -> p + op() + e\n    exp: (e, recur) -> \"(#{recur(e)})\"\n    post: (s) ->\n      s = s.replace(/\\+-/g, '-').replace(/--/g, '+')\n      if options?.result then withResult s else s\n\nclass Parsed\n  constructor: (@ast) ->\n  calc: -> calc @ast\n  render: (options) -> render @ast, options\n\nmodule.exports =\n  parse: (e) -> new Parsed parse e\n","module.exports = (function() {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { S: peg$parseS },\n        peg$startRuleFunction  = peg$parseS,\n\n        peg$c0 = { type: \"other\", description: \"expression\" },\n        peg$c1 = peg$FAILED,\n        peg$c2 = [],\n        peg$c3 = \"+\",\n        peg$c4 = { type: \"literal\", value: \"+\", description: \"\\\"+\\\"\" },\n        peg$c5 = \"-\",\n        peg$c6 = { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n        peg$c7 = function(left, right) { return add([left].concat(terms(right))); },\n        peg$c8 = { type: \"other\", description: \"term\" },\n        peg$c9 = \"*\",\n        peg$c10 = { type: \"literal\", value: \"*\", description: \"\\\"*\\\"\" },\n        peg$c11 = function(left, right) { return mul([left].concat(terms(right))); },\n        peg$c12 = { type: \"other\", description: \"fraction\" },\n        peg$c13 = \"/\",\n        peg$c14 = { type: \"literal\", value: \"/\", description: \"\\\"/\\\"\" },\n        peg$c15 = function(left, right) { return over([left].concat(terms(right))); },\n        peg$c16 = \" \",\n        peg$c17 = { type: \"literal\", value: \" \", description: \"\\\" \\\"\" },\n        peg$c18 = function(whole, left, right) { return mixed([whole, left, right]); },\n        peg$c19 = { type: \"other\", description: \"factor\" },\n        peg$c20 = null,\n        peg$c21 = \"(\",\n        peg$c22 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n        peg$c23 = \")\",\n        peg$c24 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n        peg$c25 = function(sign, expression) {\r\n            var r = exp(expression);\r\n            return sign==='-'?minus(r):r;\r\n          },\n        peg$c26 = { type: \"other\", description: \"integer\" },\n        peg$c27 = /^[0-9]/,\n        peg$c28 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n        peg$c29 = function(sign, digits) { return num(parseInt((sign||\"\")+digits.join(\"\"), 10)); },\n        peg$c30 = { type: \"other\", description: \"unsigned integer\" },\n        peg$c31 = function(digits) { return num(parseInt(digits.join(\"\"), 10)); },\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parseS() {\n      var s0;\n\n      s0 = peg$parseE();\n\n      return s0;\n    }\n\n    function peg$parseE() {\n      var s0, s1, s2, s3, s4, s5;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseT();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 43) {\n          s4 = peg$c3;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c4); }\n        }\n        if (s4 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 45) {\n            s4 = peg$c5;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c6); }\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseT();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c1;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 43) {\n              s4 = peg$c3;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c4); }\n            }\n            if (s4 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 45) {\n                s4 = peg$c5;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c6); }\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseT();\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c1;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c1;\n            }\n          }\n        } else {\n          s2 = peg$c1;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c7(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseT();\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c0); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseT() {\n      var s0, s1, s2, s3, s4, s5;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseF();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s4 = peg$c9;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseF();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c1;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 42) {\n              s4 = peg$c9;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c10); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseF();\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c1;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c1;\n            }\n          }\n        } else {\n          s2 = peg$c1;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c11(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseF();\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c8); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseF() {\n      var s0, s1, s2, s3, s4, s5;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseR();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s4 = peg$c13;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c14); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseR();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c1;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s4 = peg$c13;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c14); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseR();\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c1;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c1;\n            }\n          }\n        } else {\n          s2 = peg$c1;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c15(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseI();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s2 = peg$c16;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c17); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseU();\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 47) {\n                s4 = peg$c13;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c14); }\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parseI();\n                if (s5 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c18(s1, s3, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c1;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c1;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c1;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c1;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseR();\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c12); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseR() {\n      var s0, s1, s2, s3, s4;\n\n      peg$silentFails++;\n      s0 = peg$parseI();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s1 = peg$c5;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c6); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 43) {\n            s1 = peg$c3;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c4); }\n          }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$c20;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s2 = peg$c21;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c22); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseE();\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s4 = peg$c23;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c24); }\n              }\n              if (s4 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c25(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c1;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c1;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c1;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c19); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseI() {\n      var s0, s1, s2, s3;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c6); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 43) {\n          s1 = peg$c3;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c4); }\n        }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$c20;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c27.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c27.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c28); }\n            }\n          }\n        } else {\n          s2 = peg$c1;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c29(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c1;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c1;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c26); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseU() {\n      var s0, s1, s2;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c27.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c28); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c27.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c28); }\n          }\n        }\n      } else {\n        s1 = peg$c1;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c31(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c30); }\n      }\n\n      return s0;\n    }\n\n\r\n      function num(n){return {type:'num',arg:n};}\r\n      function add(a){return {type:'add',arg:a};}\r\n      function mul(a){return {type:'mul',arg:a};}\r\n      function over(a){return {type:'over',arg:a};}\r\n      function mixed(a){return {type:'mixed',arg:a};}\r\n      function exp(e){return {type:'exp',arg:e};}\r\n\r\n      function minus(e){return {type:\"minus\",arg:e};}\r\n\r\n      function terms(a) {\n        return a.map(function(e) {\n          return e[0] === \"-\" ? minus(e[1]) : e[1];\n        });\n      }\r\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n})();","### global module ###\n\ngcd = (n, d) ->\r\n  r = 0\r\n  until d is 0\r\n    r = n % d\r\n    n = d\r\n    d = r\r\n  Math.abs n\r\n\ndiv0 = new Error 'Division by zero!'\n\nclass Fraction\n\n  constructor: (n, d = 1) ->\n    throw div0 if d is 0\n    [n, d] = [-n, -d] if d < 0\n    div = gcd n, d\n    @n = n / div\n    @d = d / div\n\n  isProper: -> @n < @d\n\n  toFloat: -> @n / @d\n\n  toString: -> if @d is 1 then \"#{@n}\" else \"#{@n}/#{@d}\"\n\n  toMixedString: ->\n    if @isProper()\n      @toString()\n    else if @n % @d is 0\n      \"#{@n // @d}\"\n    else\n      \"#{@n // @d} #{@n % @d}/#{@d}\"\n\n  @create: (n, d) -> new Fraction n, d\n\n  @mixed: (w, n, d) -> @create n + w*d, d\n\n  @add: (l, r) ->\n    [a, b, c, d] = [l.n, l.d, r.n, r.d]\n    @create a*d + c*b, b*d\n\n  @minus = (f) ->\n    [n, d] = [f.n, f.d]\n    @create -n, d\n\n  @mul = (l, r) ->\n    [a, b, c, d] = [l.n, l.d, r.n, r.d]\n    @create a*c, b*d\n\n  @div = (l, r) ->\n    [a, b, c, d] = [l.n, l.d, r.n, r.d]\n    @create a*d, b*c\n\nmodule.exports = Fraction\r\n"],"sourceRoot":"/source/"}